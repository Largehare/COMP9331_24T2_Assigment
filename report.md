# COMP9331 Computer Networks and Applications Assignment Report

## 1. Environment Details

- **Language**: Python 3.11

- **Platform**: VLAB

## 2. Overall Program Design

The program consists of 4 parts.

### 2.1 message.py

The `Message` class is an abstract class  containing 4 members:

- `header`: Dictionary type, the first element is a 16-bit unsigned integer representing `qid`.
- `question`: Tuple, the question for the server.
- `construct`:  Constructs a message string by combining attributes of the class. E.g. assuming `message.header = {'qid':100}` and `message.question = (example.com. A)`, then the method returns `'ID: 100\r\nQUESTION SECTION:\nexample.com.\tA'` . Note that `\r\n`  is the delimiter of each section.
- `deconstruct` : The reverse function of the `construct`. This method parses the provided string to extract information and stores it in the -instance variables. E.g. assuming string `'ID: 100\r\nQUESTION SECTION:\nexample.com.\tA'` as input, then the method will set `message.header = {'qid':100}` and `message.question = (example.com. A)`.

`Message` is inherited by `ClientMessage` and `ServerMessage` these two children classes.

- `ClientMessage`: Message sent from client to server.
- `ServerMessage`: Message sent from server to client. Additionally possess `answer`, `authority` and `additional` three list type members.

### 2.2 utils.py

The utility function `split_file()` returns Resource Records (RRs) as tuples in the master.txt.

### 2.3 client.py

**Usage:** python3 client.py <port> <qname> <qtype> <timeout>

**How it works:**

1. `Client` will randomly generate a `qid` and add it to the `ClientMessage` instance with `qname` and `qtype`.
2. Establish a UDP socket and send the query string to the server. The string can be generated by the `construct` method of the `ClientMessage` instance.
3. It receives data from the server and formatting outputs it to the terminal after decoding.  
4. If the waiting time exceeds the timeout limit, it will close the socket and output “timed out” on the terminal.

### 2.4 server.py

**Usage:** python3 server.py <port>

**How it works:**

1. Read and split the master.txt using `split_file()` and store RRs in the list type cache.
2. Establish a UDP socket and listen on the specific port.
3. The server supports multiple clients by multithreading. 
4. Formatting outputs the log with timestamp, client port and so on when receiving or sending data.
5. If the received data is invalid, the server will send error information back to the client.
6. When receiving data from the client, it will parse data through the `ServerMassage` class, and then use the BFS algorithm to find the answers first. If no answer is found, it is to send the closest ancestor zone to `qname` back to the client.

## 3. Known Limitations

The program has been well tested even by some edge cases. Its output matches the example in the specification. However, some limitations still exist:

1. Maybe fail to process other flags such as SOA, those undefined behaviours (UBs).
2. The function `split_file()`  is simple. The complex master.txt which includes specific symbols, may cause the failure of the server.

## 4. Reference

[1] Multiple constructors for class: [https://www.geeksforgeeks.org/private-attributes-in-a-python-class/](https://www.geeksforgeeks.org/private-attributes-in-a-python-class/)

[2] Multithread Server: [https://github.com/ayan2809/Multi-Client-Socket-using-UDP/blob/master/server.py](https://github.com/ayan2809/Multi-Client-Socket-using-UDP/blob/master/server.py)

[3] KeyboardInterrupt: [https://stackoverflow.com/questions/34871191/cant-close-socket-on-keyboardinterrupt](https://stackoverflow.com/questions/34871191/cant-close-socket-on-keyboardinterrupt)

[4] BFS: [https://www.geeksforgeeks.org/python-program-for-breadth-first-search-or-bfs-for-a-graph/](https://www.geeksforgeeks.org/python-program-for-breadth-first-search-or-bfs-for-a-graph/)